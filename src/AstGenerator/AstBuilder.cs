namespace Pulse.AstGenerator
{
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Reflection;
    using System.Text;

    internal class AstBuilder
    {
        private const int DefaultIdentSize = 4;
        private readonly StringBuilder _builder = new StringBuilder();
        private int _indentLevel;
        private readonly string _baseNamespace;
        private readonly string _baseTypeName;
        private readonly int _indentSize;

        public AstBuilder(
            string baseNamespace,
            string baseTypeName,
            int indentSize = DefaultIdentSize)
        {
            if (string.IsNullOrWhiteSpace(baseNamespace))
            {
                throw new ArgumentNullException(nameof(baseNamespace));
            }

            _baseNamespace = baseNamespace;

            if (string.IsNullOrWhiteSpace(baseTypeName))
            {
                throw new ArgumentNullException(nameof(baseTypeName));
            }

            _baseTypeName = baseTypeName;

            _indentSize = indentSize > 0
                ? indentSize
                : DefaultIdentSize;
        }

        public string BuildAst(
            AstKind astKind,
            IEnumerable<TypeDescriptor> descriptors)
        {
            _builder.Clear();
            WriteAst(
                astKind,
                descriptors);
            return _builder.ToString();
        }

        private void WriteAst(
            AstKind astKind,
            IEnumerable<TypeDescriptor> descriptors)
        {
            if (descriptors == null)
            {
                throw new ArgumentNullException(nameof(descriptors));
            }

            // Avoid multiple enumeration
            var definitions = descriptors.ToList();
            if (definitions.Count == 0) { return; }

            WriteFileHeader();
            WriteLine($"namespace {_baseNamespace}");
            OpenBlock();

            WriteVisitor(
                astKind,
                definitions);
            WriteBaseType(astKind);
            foreach (var type in definitions)
            {
                WriteType(
                    astKind,
                    type);
            }

            CloseBlock();
        }

        private void WriteFileHeader()
        {
            var asm = Assembly.GetAssembly(typeof(AstBuilder));
            if (asm == null) { return; }

            var generatorName = asm
                .GetName()
                .Name;
            var generatorVersion = asm
                .GetCustomAttribute<AssemblyInformationalVersionAttribute>()
                ?.InformationalVersion;

            WriteLine(
                "//------------------------------------------------------------------------------");
            WriteLine("// <auto-generated>");
            WriteLine("//     This code was generated by a tool.");
            WriteLine($"//     Generator name    : {generatorName}");
            WriteLine($"//     Generator version : {generatorVersion}");
            WriteLine("//");
            WriteLine(
                "//     Changes to this file may cause incorrect behavior and will be lost if");
            WriteLine("//     the code is regenerated.");
            WriteLine("// </auto-generated>");
            WriteLine(
                "//------------------------------------------------------------------------------");
        }

        private void WriteVisitor(
            AstKind astKind,
            IEnumerable<TypeDescriptor> types)
        {
            WriteLine(
                astKind == AstKind.Expressions
                    ? $"public interface I{_baseTypeName}Visitor<out T>"
                    : $"public interface I{_baseTypeName}Visitor");
            OpenBlock();
            foreach (var definition in types)
            {
                WriteLine(
                    astKind == AstKind.Expressions
                        ? $"T Visit{definition.TypeName}({definition.TypeName} {FormatParameterName(_baseTypeName)});"
                        : $"void Visit{definition.TypeName}({definition.TypeName} {FormatParameterName(_baseTypeName)});");
            }

            CloseBlock();
        }

        private void WriteBaseType(
            AstKind astKind)
        {
            WriteLine($"public abstract class {_baseTypeName}");
            OpenBlock();

            WriteLine(
                astKind == AstKind.Expressions
                    ? $"public abstract T Accept<T>(I{_baseTypeName}Visitor<T> visitor);"
                    : $"public abstract void Accept(I{_baseTypeName}Visitor visitor);");

            CloseBlock();
        }

        private void WriteType(
            AstKind astKind,
            TypeDescriptor type)
        {
            WriteLine($"public sealed class {type.TypeName} : {_baseTypeName}");
            OpenBlock();
            WriteProperties(type);
            WriteLine();
            WriteConstructor(type);
            WriteLine();
            WriteLine(
                astKind == AstKind.Expressions
                    ? $"public override T Accept<T>(I{_baseTypeName}Visitor<T> visitor)"
                    : $"public override void Accept(I{_baseTypeName}Visitor visitor)");
            Indent();
            WriteLine($"=> visitor.Visit{type.TypeName}(this);");
            Unindent();
            CloseBlock();
        }

        private void WriteProperties(
            TypeDescriptor type)
        {
            foreach (var member in type.Members)
            {
                WriteLine(
                    $"public {member.TypeName} {FormatPropertyIdentifier(member.IdentifierName)} {{ get; }}");
            }
        }

        private void WriteConstructor(
            TypeDescriptor type)
        {
            var parameters = string.Join(
                ",",
                type.Members.Select(
                    x => $"{x.TypeName} {FormatParameterName(x.IdentifierName)}"));
            WriteLine($"public {type.TypeName}({parameters})");

            OpenBlock();
            foreach (var member in type.Members)
            {
                WriteLine(
                    $"{FormatPropertyIdentifier(member.IdentifierName)} = {FormatParameterName(member.IdentifierName)};");
            }

            CloseBlock();
        }

        private void WriteLine(
            string text = "")
        {
            _builder.AppendLine(
                $"{new string(' ', _indentLevel * _indentSize)}{text}");
        }

        private void Indent()
            => _indentLevel++;

        private void Unindent()
        {
            if (_indentLevel <= 0) { return; }

            _indentLevel--;
        }

        private void OpenBlock()
        {
            WriteLine("{");
            Indent();
        }

        private void CloseBlock()
        {
            Unindent();
            WriteLine("}");
        }

        private static string FormatPropertyIdentifier(
            string name)
            => string.IsNullOrWhiteSpace(name)
                ? name
                : name.ToUpperCaseFirst();

        private static string FormatParameterName(
            string name)
        {
            if (string.IsNullOrWhiteSpace(name)) { return name; }

            var result = name.ToLowerCaseFirst();
            return ReservedKeyword.IsKeyword(name)
                ? $"@{name}"
                : result;
        }
    }
}
